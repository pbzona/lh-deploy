import BrokenFeatureModule from '../../components/BrokenFeatureModule';
import SyntaxHighlighter from 'react-syntax-highlighter';
import { docco } from 'react-syntax-highlighter/dist/cjs/styles/hljs';

# Exercise: Testing in Production

At a minimum, LaunchDarkly gives us a new worst-case-scenario for a deploy failure: a killswitch. With LaunchDarkly in our Production environment, any feature behind a flag can simply be disabled. In this reality, what's the purpose of a QA environment at all. We don't need to maintain infrastructure purely to mimic the conditions of production, simply so we can troubleshoot an issue without impacting real traffic.

In this exercise, we'll run through a common real-life scenario and demonstrate how LaunchDarkly makes it easier to recover from an incident by reducing the number of variables that need to be accounted for in troubleshooting.

Say it's a typical Tuesday in the office. You're running through your normal duties, taking issues out of the queue and tackling them one by one, when all of a sudden you get pinged on an urgent issue escalated by the support team:

![screenshot of dramatic error ticket](/images/urgent-ticket.png)

Oh no! The feature we've been working on is broken in production, and the tickets are piling up in technical support. First thing, let's turn the flag off so we can give the support team a break.

![animation toggling flag off](/images/disable-flag.gif)

Great, now let's regroup. First, we look up the details about one of the users who reported an issue in the users tab, and it looks like this:

![screenshot of fake user](/images/user-details.png)

Yup, that's the group of users wanted to release this feature to— and it worked when we tested in our development environment— so what could the issue be? Let's reproduce this ourselves to see if we can figure out what the problem is. We're going to turn the feature back on, but only for us, so first let's ensure that nobody is receiving the feature in production by adjusting our targeting rules:

![animation changing the variation to false for the flag targeting rules](/images/change-rules-based-target.gif)

Don't forget to turn the flag back on before saving

![animation turning the flag on and clicking save](/images/turn-on-and-save.gif)

Ok, our flag is on but it's currently returning `false` for all rulesets. We grab an Android test device and login with our production credentials:

<BrokenFeatureModule moduleId="4" />

Everything is looking good. You check the app version and it's `2.0`, so this device should be able to recreate the issue. To do this, we're going to use the **Individual User Targeting** feature. Before we can use that, let's define our production user on line 12 in `module04/index.js`:

<SyntaxHighlighter showLineNumbers="true" startingLineNumber={12} language="javascript" style={docco}>
{
` const userCtx = {
    key: 'abc123',
    name: 'Gob Bluth', // Replace this value with your name
    email: 'crissangelfan99@gmail.com', // Replace this value with your email address
    custom: {
      state: 'CA',
      early_access: false,
      device: 'mobile',
      operating_system: 'android',
      browser_name: 'opera',
      app_version: '2.0'
    }
  };`
}
</SyntaxHighlighter>

Go ahead and add fill out the `firstName` and `email` attributes with your own info:

<SyntaxHighlighter showLineNumbers="true" startingLineNumber={12} language="javascript" style={docco}>
{
` const userCtx = {
    key: 'abc123',
    name: 'Gob Bluth', // Replace this value with your name
    email: 'crissangelfan99@gmail.com', // Replace this value with your email address
    custom: {
      state: 'CA',
      early_access: false,
      device: 'mobile',
      operating_system: 'android',
      browser_name: 'opera',
      app_version: '2.0'
    }
  };`
}
</SyntaxHighlighter>

If your code looks similar to the above code, go ahead and save the file.

Alright, now that we know our production credentials, let's add ourselves to the `true` variation group in the **Individual Targeting** section of the flag targeting panel, then save the change.

![animation of adding user, clicking save](/images/individual-user.gif)

Now let's check our app to see if we're receiving the issue:

<BrokenFeatureModule moduleId="4" />

Yup, there it is. Interesting. Let's have a look at the code to see what the difference is in production. You can find the feature code on line 35 of `module04/index.js`:

<SyntaxHighlighter showLineNumbers="true" startingLineNumber={35} language="javascript" style={docco}>
{
`if (useNewConfig) {
  config = new AppConfiguration(options);
    } else {
      config = new LegacyAppConfiguration(options);
    }
  config.loadFromFile('/var/opt/myApp/config.json');
  // ---------------------------
  // Do not edit below this line
  configValid = config.validate();
  dependenciesSatisfied = config.checkDependencies();
}
return {
flagValue: useNewConfig,
featureIsWorking: configValid && dependenciesSatisfied // Check Feature Dependencies
};`
}
</SyntaxHighlighter>

Interesting, nothing seems to stand out in the feature code— but what's this?

<SyntaxHighlighter showLineNumbers="true" startingLineNumber={47} language="javascript" style={docco}>
{
`return {
  flagValue: useNewConfig,
  featureIsWorking: configValid && dependenciesSatisfied //Check Feature Dependencies
};`
}
</SyntaxHighlighter>

Before the feature can run at all, it looks like we're doing a dependency check.

<SyntaxHighlighter showLineNumbers="true" startingLineNumber={45} language="javascript" style={docco}>
{
`  dependenciesSatisfied = config.checkDependencies();`
}
</SyntaxHighlighter>

Let's have a look at the `module04/dependencies.js` file.

<SyntaxHighlighter showLineNumbers="true" language="javascript" style={docco}>
{
`module.exports = {
  "critical-dependency": "0.4",
  "featurizer": "1.8",
  "dark-launchly": "3.1"
}`
}
</SyntaxHighlighter>

Interesting, `critical-dependency` in production is at version `0.4`— that satisfies the dependency check for this feature, but is it the same version we used when we developed this feature? Let's refer back to `module02/dependencies.js` to see what the version is there:

<SyntaxHighlighter showLineNumbers="true" language="javascript" style={docco}>
{
`module.exports = {
  "critical-dependency": "0.6",
  "featurizer": "1.8",
  "dark-launchly": "3.1"
}`
}
</SyntaxHighlighter>

A HA! It's a different dependency version, `0.6`, just as we suspected! We do a quick codescan, and the only feature using this dependency is ours (nice how everything works out perfectly in a made up scenario, huh?). Let's go ahead and update the dependency now in `module04/dependencies.js`, like so:

<SyntaxHighlighter showLineNumbers="true" language="javascript" style={docco}>
{
`module.exports = {
  "critical-dependency": "0.6",
  "featurizer": "1.8",
  "dark-launchly": "3.1"
}`
}
</SyntaxHighlighter>


If the dependencies file matches the above sample, go ahead and save it.

Great! Now that we've updated the dependency, let's check to see if the feature is working for us!

<BrokenFeatureModule moduleId="4" />

Looking great. Okay, last thing. Let's remove ourselves from the test group and turn the feature back on for Android users on app version 2.0:

![animation of removing individual target, flipping targeting rule back to true](/images/remove-individual-user.gif)

Don't forget to save!

![animation of clicking teh save button](/images/final-save.gif)

Great, now let's double check that the app is still working:

<BrokenFeatureModule moduleId="4" />

It's fixed! Amazing. And we were able to do all that purely by comparing a dev file to production and updating a fixing a dependency mismatch. Can you imagine how needing to recreate the issue in a QA environment would have been an extra, unneccessary step in this scenario?